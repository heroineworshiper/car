/*
 * REMOTE CONTROL RECEIVER FOR CAR
 * Copyright (C) 2020-2024 Adam Williams <broadcast at earthling dot net>
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 * 
 */



#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <xc.h>
#include <pic18f14k50.h>

// receiver using 433Mhz Si4463
// use test_receive.c to view the output

// to program a dead chip with the home made programmer
// enable internal RC + PLL
// /amazon/root/car/usb_programmer -p 18f14k50 -c 0x300000 0011100000000000
// enable watchdog + brownout
// /amazon/root/car/usb_programmer -p 18f14k50 -c 0x300002 0001111100011110
// disable PGM & extended instructions
// /amazon/root/car/usb_programmer -p 18f14k50 -c 0x300006 0000000000000000

// write the hex file
// /amazon/root/car/usb_programmer -p 18f14k50 car_receive.X.production.hex


// PIC18F14K50 Configuration Bit Settings

// 'C' source line config statements


// CONFIG1H
//#pragma config FOSC = IRCCLKOUT // Oscillator Selection bits (Internal RC oscillator, CLKOUT function on OSC2)
#pragma config FOSC = IRC // Oscillator Selection bits (Internal RC oscillator, GPIO on OSC2)
#pragma config PLLEN = ON      // 4 X PLL Enable bit

// CONFIG2L
#pragma config PWRTEN = OFF     // Power-up Timer Enable bit (PWRT disabled)
#pragma config BOREN = SBORDIS  // Brown-out Reset Enable bits (Brown-out Reset enabled in hardware only (SBOREN is disabled))
#pragma config BORV = 22        // Brown-out Reset Voltage bits (VBOR set to 3.0 V nominal)

// CONFIG2H
#pragma config WDTEN = ON       // Watchdog Timer Enable bit (WDT is always enabled. SWDTEN bit has no effect.)
#pragma config WDTPS = 32768    // Watchdog Timer Postscale Select bits (1:32768)

// CONFIG3H
#pragma config HFOFST = OFF     // HFINTOSC Fast Start-up bit (The system clock is held off until the HFINTOSC is stable.)

// CONFIG4L
#pragma config LVP = OFF        // Single-Supply ICSP Enable bit (Single-Supply ICSP disabled)



// print debug to the UART.  The ARM has to forward it.
//#define DEBUG

// 45mA with Si4463.  Required to bit bang radio
#define CLOCKSPEED 32000000

// the system clock & the number of packets per second
#define HZ 50
// number of HZ when scanning
#define DWELL_TIME 5

// delay between packets
#define TIMER0_PERIOD (CLOCKSPEED / 4 / 32 / HZ)
// time before next packet we should hop (10ms)
#define HOP_LAG (CLOCKSPEED / 4 / 32 / 100)


const uint8_t PACKET_KEY[] = 
{
    0x5b, 0xb1, 0x6e, 0x6b, 0x33, 0x30, 0x9e, 0x08
};

const uint8_t DATA_KEY[] =
{
    0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55
};

#define DATA_SIZE 12

// This was generated by the same configuration as the Si4463 transmitter
#include "radio_config.h"
const uint8_t radio_config[] = RADIO_CONFIGURATION_DATA_ARRAY;


#define LED_LAT LATCbits.LATC5
#define LED_TRIS TRISCbits.TRISC5

#define RADIO_CS_LAT LATB6
#define RADIO_CS_TRIS TRISB6

#define RADIO_SCK_LAT LATC1
#define RADIO_SCK_TRIS TRISC1

#define RADIO_MOSI_LAT LATB4
#define RADIO_MOSI_TRIS TRISB4

#define RADIO_MISO_PORT PORTCbits.RC2
#define RADIO_MISO_TRIS TRISC2

#define RADIO_SDN_LAT LATC6
#define RADIO_SDN_TRIS TRISC6



// delay to warm up the radio is 1ms  page 19
#define RADIO_DELAY (-CLOCKSPEED / 4 / 4 / 1000)
// multiple of clockspeed
#define BAUD 100000

#define TOTAL_CHANNELS 2


// configuration bits corresponding to each base frequency
// RF_FREQ_CONTROL_INTE_8 bytes 4-7
const uint8_t pll_values[] =
{
//    0x38, 0x0E, 0x22, 0x22, // 433.25Mhz
    0x38, 0x0E, 0x66, 0x66, // 433.5Mhz
//    0x38, 0x0E, 0xAA, 0xAA, // 433.75
//    0x38, 0x0E, 0xEE, 0xEE, // 434.0Mhz
    0x38, 0x0F, 0x33, 0x33, // 434.25
//    0x38, 0x0F, 0x77, 0x77, // 434.5Mhz
};

// RF_MODEM_AFC_LIMITER_1_3 bytes 5-6
const uint8_t afc_values[] = 
{
//    0xAD, 0x80,
    0xAD, 0x80,
//    0xAD, 0x80,
    0xAD, 0x80,
};




typedef union 
{
	struct
	{
		unsigned interrupt_complete : 1;
        unsigned scanning : 1;
        unsigned got_packet : 1;
	};
	
	unsigned char value;
} flags_t;


volatile flags_t flags;
volatile uint32_t tick = 0;
volatile uint8_t current_channel = 0;
volatile uint8_t missed_packets = 0;
#define MAX_MISSED_PACKETS HZ

volatile uint8_t serial_in;
volatile uint8_t key_offset;
volatile uint8_t data_offset;
volatile uint8_t serial_data[DATA_SIZE];
void (*receive_state)();
// mane timer value when the last packet was received
volatile uint16_t start_time;




#define UART_BUFSIZE 64
uint8_t uart_buffer[UART_BUFSIZE];
uint8_t uart_size = 0;
uint8_t uart_position1 = 0;
uint8_t uart_position2 = 0;

uint16_t chars_received = 0;


// send a UART char
void handle_uart()
{
// clear the overflow bit
    if(RCSTAbits.OERR)
    {
        RCSTAbits.OERR = 0;
        RCSTAbits.CREN = 0;
        RCSTAbits.CREN = 1;
    }

    if(uart_size > 0 && PIR1bits.TXIF)
    {
        PIR1bits.TXIF = 0;
        TXREG = uart_buffer[uart_position2++];
		uart_size--;
		if(uart_position2 >= UART_BUFSIZE)
		{
			uart_position2 = 0;
		}
    }
}


// must be unrolled to work at low clockspeed
void si4463_write(uint8_t data)
{
// It really needs the ? 1 : 0
    RADIO_MOSI_LAT = (data & 0x80) ? 1 : 0;
    RADIO_SCK_LAT = 1;
    RADIO_SCK_LAT = 0;
    RADIO_MOSI_LAT = (data & 0x40) ? 1 : 0;
    RADIO_SCK_LAT = 1;
    RADIO_SCK_LAT = 0;
    RADIO_MOSI_LAT = (data & 0x20) ? 1 : 0;
    RADIO_SCK_LAT = 1;
    RADIO_SCK_LAT = 0;
    RADIO_MOSI_LAT = (data & 0x10) ? 1 : 0;
    RADIO_SCK_LAT = 1;
    RADIO_SCK_LAT = 0;
    RADIO_MOSI_LAT = (data & 0x8) ? 1 : 0;
    RADIO_SCK_LAT = 1;
    RADIO_SCK_LAT = 0;
    RADIO_MOSI_LAT = (data & 0x4) ? 1 : 0;
    RADIO_SCK_LAT = 1;
    RADIO_SCK_LAT = 0;
    RADIO_MOSI_LAT = (data & 0x2) ? 1 : 0;
    RADIO_SCK_LAT = 1;
    RADIO_SCK_LAT = 0;
    RADIO_MOSI_LAT = (data & 0x1) ? 1 : 0;
    RADIO_SCK_LAT = 1;
    RADIO_SCK_LAT = 0;
}

uint8_t si4463_read()
{
    uint8_t data = 0;
    RADIO_MOSI_LAT = 0;
    RADIO_SCK_LAT = 1;
    if(RADIO_MISO_PORT) data |= 0x80;
    RADIO_SCK_LAT = 0;
    RADIO_SCK_LAT = 1;
    if(RADIO_MISO_PORT) data |= 0x40;
    RADIO_SCK_LAT = 0;
    RADIO_SCK_LAT = 1;
    if(RADIO_MISO_PORT) data |= 0x20;
    RADIO_SCK_LAT = 0;
    RADIO_SCK_LAT = 1;
    if(RADIO_MISO_PORT) data |= 0x10;
    RADIO_SCK_LAT = 0;
    RADIO_SCK_LAT = 1;
    if(RADIO_MISO_PORT) data |= 0x8;
    RADIO_SCK_LAT = 0;
    RADIO_SCK_LAT = 1;
    if(RADIO_MISO_PORT) data |= 0x4;
    RADIO_SCK_LAT = 0;
    RADIO_SCK_LAT = 1;
    if(RADIO_MISO_PORT) data |= 0x2;
    RADIO_SCK_LAT = 0;
    RADIO_SCK_LAT = 1;
    if(RADIO_MISO_PORT) data |= 0x1;
    RADIO_SCK_LAT = 0;
    return data;
}

// wait for clear to send
void si4463_cts()
{
    uint16_t retries = 10000;
    while(retries > 0)
    {
        RADIO_CS_LAT = 0;
        si4463_write(0x44);
        uint8_t cts = si4463_read();
        RADIO_CS_LAT = 1;
        
        if(cts == 0xff) break;
        retries--;
    }

    if(retries == 0)
    {
        LED_LAT = 0;
        asm("reset");
    }
}

// radio_comm_SendCmdGetResp
// send the command without CTS
// never called with a response byte count so we neglect the response
void si4463_command(const uint8_t *ptr, uint8_t len)
{
    RADIO_SCK_LAT = 0;
    RADIO_CS_LAT = 0;
    uint8_t i;
    for(i = 0; i < len; i++)
    {
        si4463_write(*ptr++);
    }
    RADIO_CS_LAT = 1;
}


void init_radio()
{
// enable outputs
    RADIO_CS_LAT = 1;
    RADIO_CS_TRIS = 0;
    
    RADIO_MOSI_LAT = 0;
    RADIO_MOSI_TRIS = 0;
    
    RADIO_SCK_LAT = 0;
    RADIO_SCK_TRIS = 0;


// toggle shutdown pin to satisfy POR
    RADIO_SDN_LAT = 1;
    RADIO_SDN_TRIS = 0;

    uint8_t init_delay = 0;
    while(init_delay < HZ / 4)
    {
        if(INTCONbits.TMR0IF)
        {
            TMR0 = -TIMER0_PERIOD;
            INTCONbits.TMR0IF = 0;
            init_delay++;
        }
    }

    RADIO_SDN_LAT = 0;

    init_delay = 0;
    while(init_delay < HZ / 4)
    {
        if(INTCONbits.TMR0IF)
        {
            TMR0 = -TIMER0_PERIOD;
            INTCONbits.TMR0IF = 0;
            init_delay++;
        }
    }

// parse radio config data
// si446x_configuration_init
    const uint8_t *ptr = radio_config;
    while(*ptr != 0)
    {
        uint8_t len = *ptr++;
        si4463_command(ptr, len);
        si4463_cts();
        ptr += len;
    }

    uint8_t rf_freq_control_inte_8[] = { RF_FREQ_CONTROL_INTE_8 };
    uint8_t rf_modem_afc_limiter_1_3[] = { RF_MODEM_AFC_LIMITER_1_3 };
    rf_freq_control_inte_8[4] = pll_values[current_channel * 4 + 0];
    rf_freq_control_inte_8[5] = pll_values[current_channel * 4 + 1];
    rf_freq_control_inte_8[6] = pll_values[current_channel * 4 + 2];
    rf_freq_control_inte_8[7] = pll_values[current_channel * 4 + 3];
    rf_modem_afc_limiter_1_3[5] = afc_values[current_channel * 2 + 0];
    rf_modem_afc_limiter_1_3[6] = afc_values[current_channel * 2 + 1];
    si4463_command(rf_freq_control_inte_8, sizeof(rf_freq_control_inte_8));
    si4463_cts();
    si4463_command(rf_modem_afc_limiter_1_3, sizeof(rf_modem_afc_limiter_1_3));
    si4463_cts();

    
// page 37
    const uint8_t rx_command[] = { 0x32, 0, 0, 0, 0, 0, 0 };
    si4463_command(rx_command, sizeof(rx_command));
}




void print_byte(uint8_t c)
{
	if(uart_size < UART_BUFSIZE)
	{
		uart_buffer[uart_position1++] = c;
		uart_size++;
		if(uart_position1 >= UART_BUFSIZE)
		{
			uart_position1 = 0;
		}
	}
}


#ifdef DEBUG
void print_text(const uint8_t *s)
{
	while(*s != 0)
	{
		print_byte(*s);
		s++;
	}
}


void print_number_nospace(uint16_t number)
{
	if(number >= 10000) print_byte('0' + (number / 10000));
	if(number >= 1000) print_byte('0' + ((number / 1000) % 10));
	if(number >= 100) print_byte('0' + ((number / 100) % 10));
	if(number >= 10) print_byte('0' + ((number / 10) % 10));
	print_byte('0' + (number % 10));
}

void print_number(uint16_t number)
{
    print_number_nospace(number);
   	print_byte(' ');
}

void print_bin(uint8_t number)
{
	print_byte((number & 0x80) ? '1' : '0');
	print_byte((number & 0x40) ? '1' : '0');
	print_byte((number & 0x20) ? '1' : '0');
	print_byte((number & 0x10) ? '1' : '0');
	print_byte((number & 0x8) ? '1' : '0');
	print_byte((number & 0x4) ? '1' : '0');
	print_byte((number & 0x2) ? '1' : '0');
	print_byte((number & 0x1) ? '1' : '0');
}
#else // DEBUG
void print_text(const uint8_t *s) {}
void print_number_nospace(uint16_t number) {}
void print_number(uint16_t number) {}
void print_bin(uint8_t number) {}

#endif // !DEBUG


void serial_on()
{
// serial port
    TXSTA = 0b00100100;
    RCSTA = 0b10010000;
    BAUDCON = 0b00001000;
// baud = clockspeed / (4 * (SPBRG + 1))
    SPBRG = CLOCKSPEED / 4 / BAUD - 1;
    PIR1bits.RCIF = 0;
    PIE1bits.RCIE = 1;
}

void get_key();
void get_data()
{
// get data from radio
    serial_data[data_offset++] = serial_in;
    if(data_offset >= DATA_SIZE)
    {
        key_offset = 0;
        receive_state = get_key;
        
        uint8_t i;
        uint8_t failed = 0;

// XOR the data key
        for(i = 0; i < DATA_SIZE; i++)
        {
            serial_data[i] ^= DATA_KEY[i];
        }


        for(i = 3; i < DATA_SIZE; i += 3)
        {
            if(serial_data[0] != serial_data[i] ||
                serial_data[1] != serial_data[i + 1] ||
                serial_data[2] != serial_data[i + 2])
            {
// reject packet if any value is different
                failed = 1;
                break;
            }
        }

// valid packet
        if(!failed)
        {
            LED_LAT = !LED_LAT;
// cue the bottom half to send values to the host
            flags.got_packet = 1;
            flags.scanning = 0;
            missed_packets = 0;

            uint8_t code_byte = serial_data[2];
            current_channel = ((code_byte >> 5) & 0x3);

//print_text("GOT CHAN=");
//print_number(current_channel);
//print_text("\n");
// set the next hop to the start time of this packet + 1 tick - HOP_LAG
        }
    }
}

void get_key()
{
// get packet key from radio
    if(serial_in == PACKET_KEY[key_offset])
    {
        if(key_offset == 0)
        {
            start_time = TMR0;
        }

        key_offset++;
        if(key_offset >= sizeof(PACKET_KEY))
        {
            receive_state = get_data;
            data_offset = 0;
            key_offset = 0;
        }
    }
    else
    if(serial_in == PACKET_KEY[0])
    {
        key_offset = 1;
        start_time = TMR0;
    }
    else
    if(key_offset > 0)
    {
        key_offset = 0;
    }
}


void main()
{
    OSCCON = 0b11100000;


// LED on
    LED_LAT = 0;
    LED_TRIS = 0;
    ANSEL = 0b00000000;
    ANSELH = 0b00000000;

	flags.value = 0;
    tick = 0;
    key_offset = 0;
    receive_state = get_key;
// mane timer
// 1:32 prescaler for 32Mhz clock
    T0CON = 0b10000100;

    init_radio();
    serial_on();

    TMR0 = -TIMER0_PERIOD;

    INTCON = 0b11100000;

    while(1)
    {
        handle_uart();

// guaranteed to fire before the radio gets the next packet
        if(flags.got_packet)
        {
            flags.got_packet = 0;
            print_byte(0xff);
            print_byte(0xe7);
            print_byte(serial_data[0]);
            print_byte(serial_data[1]);
            print_byte(serial_data[2]);
        }
    }
    
}

void interrupt isr()
{
	while(1)
	{
		ClrWdt();
		flags.interrupt_complete = 1;

// tick counter
		if(INTCONbits.TMR0IF)
		{
			flags.interrupt_complete = 0;
			INTCONbits.TMR0IF = 0;
            TMR0 = -TIMER0_PERIOD;
            tick++;
        }

// serial port
        if(PIR1bits.RCIF)
        {
            flags.interrupt_complete = 0;
//            LED_LAT = !LED_LAT;
            serial_in = RCREG;
            PIR1bits.RCIF = 0;
//            chars_received++;
            receive_state();
        }
        
		if(flags.interrupt_complete) break;
    }
}










